# 컬렉션 자료구조
## 대표적으로 내장 컬렉션에는 set, dict
### 주로 맴버십 연산자 in, 크기함수 len(), 순회를 사용
>#### set(집합)
>##### 1. 중복x, 정렬x
> * 인덱스 연산 불가능, in 연산 및 중복 제거시 사용 
>   - frozen set은 set과 다른 객체이므로 set의 몇개의 기능을 사용할 수 없음
> ##### 2. 삽입시 시간복잡도는 O(1), 합집합의 시간복잡도는 O(m + n) 교집합의 경우 O(n)
<hr/>

>#### set 메소드
>##### 1. discard(), remove(), pop()
>* discard 메소드는 제거만하고 반환값은 없음 remove는 항목이 없는경우 예외발생, pop는 무작위로 제거 후 항목 반환
<hr/>
<hr/>
>##### 2. 문자열 메소드
>* join()
>   - '문자열'.join
>       + 리스트에 있는 문자들을 해당 문자열로 결합해서 반환
>* ljust, rjust()
>   - '문자열'.ljust('해당 문자로 채울 갯수', '채울 문자')
>       + l/r은 문자열을 왼/오른쪽에 두고 문자열이 끝나는 공간부터 채울 문자로 앞에 선언한 갯수만큼 나열
>* format()
>   - {} {} {}.format('채울내용', '채울내용')
>       + 필드 이름이나 인덱스를 생략 가능하고 지정해서 넣을 수 있음 
>* splitlines, split 메소드
>   - 문자열.splitlines(), 문자열.split(기준, 분리할 횟수) 
>       + 결과 값을 문자열 리스트로 반환 split 메소드는 rsplit 메소드도 있음
>* index / find (sub, start, end) 메소드
>   - index 메소드 의 경우, 문자열 A에서 부분 문자열 sub의 인덱스 위치를 반환, 실패시 ValueError
>   - find 메소드의 경우, 실패시 -1 반환
>       + 오류를 정수로 판단시 find 메소드를 이용하고, Error로 예외처리를 하여 사용하는 경우에는 index 메소드가 좋은것 같다.
>* f-strings
>   - 문자열앞에 접두사 f를 붙여 사용
>       +   repr(),str() !r 메소르를 사용하는 경우, 디버깅을 위해 일부 변수를 빠르게 표시하기위해 사용
>           + f"context {var1} {var2} {var3}"  __날짜 포맷, 정수 포맷 지정자 사용 가능__
>               + 파이썬이 가지는 매력적인 기능인 것 같다. 

<hr/>

>#### 튜플
>##### 튜플 언패킹
>* 변수를 할당하는 문장에서 왼쪽에 두 개 이상의 변수를 사용하고 한 변수 앞에 * 연산자가 붙는 경우, 오른쪽 값들 중 할당되고 남은 값들이 *연산자가 붙은 변수에 할당
>   - x, *y = (1,2,3,4) 인경우 x에 1 y에 [2,3,4] 값 대입
>##### 네임드 튜플
>* collections 표준 모듈에 있는 데이터 타입 
>   - 기존의 튜플과 다른점은 인덱스 위치와 이름을 통해 참조 가능